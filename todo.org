#+TITLE: Jotly Development Blueprint & Prompts
#+AUTHOR: Gemini Agent
#+DATE: 2025-12-02
#+OPTIONS: toc:t

* Overview
This document outlines the step-by-step plan to build "Jotly", an Android clone of Journelly.
It provides a series of specific prompts designed for a code-generation LLM to implement the application iteratively.
Each step focuses on a small, testable unit of work, adhering to Test-Driven Development (TDD) principles where possible.

* Phase 1: Infrastructure & Data Layer Foundation
** DONE Step 1: Project Initialization & Nix Setup
CLOSED: [2025-12-02]
- [X] Initialize the Android project:
  - [X] Use the latest stable version of Android Studio/Gradle plugins.
  - [X] Setup Jetpack Compose for the UI.
  - [X] Setup Hilt for Dependency Injection.
  - [X] Setup JUnit 4/5 and Espresso dependencies.
  - [X] Ensure the project builds and runs a "Hello World" screen.
- [X] Configure Nix Flakes:
  - [X] Initialize a `flake.nix` using `flake-parts`.
  - [X] Configure a devShell providing `jdk`, Android SDK, `gradle`, and `android-tools` (adb, etc).
  - [X] Integrate `cachix/git-hooks.nix` for pre-commit hooks (ktlint, alejandra).
  - [X] Ensure `nix develop` drops into a usable environment.
- [X] Create GitHub Actions CI workflow with SHA-pinned actions.
- [X] Create .editorconfig for ktlint Compose function naming rules.
- [X] Ensure all CI checks pass.

** TODO Step 2: File System Abstraction
- [ ] Create an interface `FileService`.
- [ ] Implement `RealFileService` that can:
  - [ ] Read the content of a file given a path (returning `Result<String>`).
  - [ ] Write content to a file given a path (returning `Result<Unit>`).
  - [ ] Check if a file exists.
  - [ ] Create a directory if it doesn't exist.
- [ ] Use Kotlin's `java.io.File` or `java.nio`.
- [ ] Create a Unit Test `FileServiceTest` using a temporary folder to verify reading/writing/existence checks work correctly.

** TODO Step 3: User Preferences (File Path Storage)
- [ ] Add Jetpack DataStore preferences dependency.
- [ ] Create `UserPreferencesRepository`.
- [ ] Implement `getJournalPath(): Flow<String?>` and `setJournalPath(path: String)`.
- [ ] Create a Unit Test verifying the flow emits the saved values.

* Phase 2: Domain Logic (Org Mode Parsing)
** TODO Step 4: Domain Model & Basic Parser
- [ ] Create a data class `JournalEntry(val id: String, val date: LocalDateTime, val content: String)`.
  - [ ] Use the date as the ID source or generate a UUID.
- [ ] Create `OrgParser` object/class.
- [ ] Implement `parse(content: String): List<JournalEntry>`.
  - [ ] Assume entries start with `* Date format...` or just a timestamp line.
  - [ ] Handle the standard Org date format: `* <2025-12-02 Tue> Title/Summary`.
- [ ] Create `OrgParserTest` with sample Org string (2 entries) and assert correct parsing.

** TODO Step 5: Parser Serialization (Round Trip)
- [ ] Add `toOrgString(entry: JournalEntry): String` to `OrgParser`.
- [ ] Ensure the output format matches the input format expected by the parser.
- [ ] Update `OrgParserTest` to verify a "Round Trip": `parse(toOrgString(entry)) == entry`.

** TODO Step 6: Journal Repository
- [ ] Inject `FileService`, `UserPreferencesRepository`, and `OrgParser` into `JournalRepository`.
- [ ] Implement `getEntries(): Flow<List<JournalEntry>>`.
  - [ ] Read the path from preferences, read the file, parse it, and emit the list.
- [ ] Implement `addEntry(entry: JournalEntry)`.
  - [ ] Read the file, append the new entry string, and write it back.
- [ ] Create a Test Double for `FileService` and `Preferences` to unit test the Repository logic without real files.

* Phase 3: Setup UI Flow
** TODO Step 7: Onboarding Logic (ViewModel)
- [ ] Implement `state` that reflects: `Loading`, `PathNeeded`, `FileMissing(path)`, `Ready`.
- [ ] On init, check `UserPreferencesRepository`.
  - [ ] If path is null -> `PathNeeded`.
  - [ ] If path exists but file missing -> `FileMissing`.
  - [ ] If file exists -> `Ready`.
- [ ] Add method `setPath(path: String)` which validates and saves.
- [ ] Add method `createFile(path: String)` which uses `FileService` to create an empty file.
- [ ] Unit test these states.

** TODO Step 8: Onboarding UI
- [ ] Create a Composable `OnboardingScreen` that observes the ViewModel.
- [ ] UI States:
  - [ ] Button to "Select File" (Use Android System File Picker contract).
  - [ ] If "FileMissing", show a prompt: "File not found. Create new?"
- [ ] Wire up the System File Picker to call `viewModel.setPath`.

** TODO Step 9: Navigation Wiring
- [ ] Create a `MainActivity` that hosts a `NavHost`.
- [ ] Define routes: "onboarding", "home".
- [ ] Use a `MainViewModel` or `LauncherEffect` to check preferences.
  - [ ] If path is set -> Navigate "home".
  - [ ] Else -> Navigate "onboarding".
- [ ] Ensure the Onboarding screen navigates to Home upon "Ready" state.

* Phase 4: Main Feed Feature
** TODO Step 10: Entry Card UI
- [ ] Create `EntryCard(entry: JournalEntry)`.
- [ ] Display Date formatted nicely (e.g., "Tue, Dec 2").
- [ ] Display Content body.
- [ ] Handle Markdown-like styling if possible, or just plain text for now.
- [ ] Create a `@Preview` with dummy data.

** TODO Step 11: Feed Screen
- [ ] `FeedViewModel` calls `JournalRepository.getEntries()`.
- [ ] `FeedScreen` uses `LazyColumn` to render a list of `EntryCard`.
- [ ] Add a Floating Action Button (FAB) with a "+" icon (Action to be defined later).
- [ ] Handle "Loading" and "Empty" states (e.g., "No entries yet").

* Phase 5: Writing Entries
** TODO Step 12: Editor UI
- [ ] Create `EditorScreen` with a `TextField` taking up most of the screen.
- [ ] Add a "Save" button in the TopAppBar.
- [ ] Manage local state for the text input.
- [ ] Handle system back press (maybe prompt to discard if dirty?).

** TODO Step 13: Saving Logic
- [ ] `EditorViewModel` should have a `saveEntry(content: String)` function.
- [ ] This creates a `JournalEntry` with `LocalDateTime.now()` and calls `repository.addEntry()`.
- [ ] Wire `FeedScreen` FAB to navigate to `EditorScreen`.
- [ ] On Save success, pop back stack to `FeedScreen`.

* Phase 6: Image Asset Support
** TODO Step 14: Asset Infrastructure
- [ ] `AssetRepository` needs the base journal path.
- [ ] Implement `saveImage(uri: Uri): String`.
  - [ ] Calculates path: `JournalPath.assets/images/UUID.jpg`.
  - [ ] Copies data from Uri to that path.
  - [ ] Returns the *relative* path or filename to be stored in the text file.

** TODO Step 15: Parsing Images
- [ ] Update `JournalEntry` to have a list of `images: List<String>` or keep it in content.
  - [ ] Better approach: Keep in content, but have a Helper to extract image paths for the UI.
- [ ] Create a Regex helper to find `[[file:(.*?)]]`.
- [ ] Test that the parser leaves the string as is, but we can extract the path.

** TODO Step 16: Image UI Integration
- [ ] Update `EntryCard`: Parse content for image links. If found, load the image using Coil or Glide.
  - [ ] Need to resolve relative path against the absolute parent folder.
- [ ] Update `EditorScreen`: Add an "Add Image" button.
  - [ ] Use `ActivityResultContracts.GetContent()`.
  - [ ] On selection, call `AssetRepository.saveImage`.
  - [ ] Insert `[[file:relative_path.jpg]]` into the text field at cursor position.

* Phase 7: Polish
** TODO Step 17: Deletion & Swipe
- [ ] Add `deleteEntry(entry: JournalEntry)` to `JournalRepository`.
  - [ ] This requires reading the file, filtering out the entry (matching by ID/Date), and rewriting the file.
- [ ] Add Swipe-to-dismiss behavior to `FeedScreen`'s LazyColumn.
- [ ] Call ViewModel delete function on swipe.
